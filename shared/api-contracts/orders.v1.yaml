openapi: 3.1.0
info:
  title: Orders Composite (Orchestrator) API
  version: 1.0.0
  description: >
    Orchestrates checkout and order finalization across Inventory, Promotions, and
    Payments services using the orchestration pattern. Provides pricing, end-to-end
    place-order, order status, and cancellation with saga compensation (release
    reservations on failure/cancel).

servers:
  - url: https://orders-composite.{env}.example.com/v1
    variables:
      env: { default: staging, enum: [local, staging, prod] }
  - url: http://orders-composite-service:8000/v1
    description: In-cluster/internal (Docker/K8s)

tags:
  - name: Pricing
  - name: Orders
  - name: Health
  - name: Events (schemas)

paths:
  /pricing/quote:
    post:
      tags: [Pricing]
      operationId: getPricingQuote
      summary: Price a cart (no reservation, no payment)
      description: >
        Enriches items with product data from Inventory and applies Promotions to
        return a priced cart. No stock is reserved by this endpoint.
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - $ref: '#/components/parameters/XRequestID'
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/PricingRequest' }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema: { $ref: '#/components/schemas/PricingResult' }
        '400': { $ref: '#/components/responses/BadRequest' }
        '401': { $ref: '#/components/responses/Unauthorized' }
        '422': { $ref: '#/components/responses/Unprocessable' }
        '500': { $ref: '#/components/responses/ServerError' }

  /orders:
    post:
      tags: [Orders]
      operationId: placeOrder
      summary: Orchestrate full order (reserve → price → pay → commit → receipt)
      description: >
        Steps: (1) reserve stock in Inventory, (2) compute pricing with Promotions,
        (3) initiate/confirm payment via Payments, (4) commit reservation on success,
        (5) persist receipt, (6) return consolidated result. On failure, releases
        reservation (saga compensation). Use X-Idempotency-Key to protect retries.
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - $ref: '#/components/parameters/XRequestID'
        - $ref: '#/components/parameters/XIdempotencyKey'
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/PlaceOrderRequest' }
      responses:
        '202':
          description: Accepted; orchestration started (for async providers)
          content:
            application/json:
              schema: { $ref: '#/components/schemas/OrderComposite' }
        '200':
          description: Completed synchronously
          content:
            application/json:
              schema: { $ref: '#/components/schemas/OrderComposite' }
        '400': { $ref: '#/components/responses/BadRequest' }
        '401': { $ref: '#/components/responses/Unauthorized' }
        '409':
          description: Insufficient stock or conflict
          content:
            application/problem+json:
              schema: { $ref: '#/components/schemas/Problem' }
        '422': { $ref: '#/components/responses/Unprocessable' }
        '500': { $ref: '#/components/responses/ServerError' }

  /orders/{orderId}:
    get:
      tags: [Orders]
      operationId: getOrder
      summary: Get composite order status/details
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - $ref: '#/components/parameters/OrderId'
        - $ref: '#/components/parameters/XRequestID'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema: { $ref: '#/components/schemas/OrderComposite' }
        '401': { $ref: '#/components/responses/Unauthorized' }
        '404': { $ref: '#/components/responses/NotFound' }
        '500': { $ref: '#/components/responses/ServerError' }

  /orders/{orderId}/cancel:
    post:
      tags: [Orders]
      operationId: cancelOrder
      summary: Cancel an in-flight order (compensation)
      description: >
        Releases reservation if still held; if payment succeeded but shipment
        not started, this may trigger a refund flow (implementation-dependent).
      security: [{ ApiKeyAuth: [] }]
      parameters:
        - $ref: '#/components/parameters/OrderId'
        - $ref: '#/components/parameters/XRequestID'
        - $ref: '#/components/parameters/XIdempotencyKey'
      responses:
        '200':
          description: Cancelled (or already terminal)
          content:
            application/json:
              schema: { $ref: '#/components/schemas/OrderComposite' }
        '401': { $ref: '#/components/responses/Unauthorized' }
        '404': { $ref: '#/components/responses/NotFound' }
        '409':
          description: Cannot cancel (already shipped/locked)
          content:
            application/problem+json:
              schema: { $ref: '#/components/schemas/Problem' }
        '500': { $ref: '#/components/responses/ServerError' }

  /health:
    get:
      tags: [Health]
      operationId: health
      summary: Service health
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object
                properties:
                  status: { type: string, enum: [UP] }
                  ip: { type: string }

components:
  securitySchemes:
    ApiKeyAuth:
      type: apiKey
      in: header
      name: api_gateway_key

  parameters:
    OrderId:
      name: orderId
      in: path
      required: true
      schema: { type: string, format: uuid }
    XRequestID:
      name: X-Request-ID
      in: header
      schema: { type: string }
      description: Correlation ID carried across services
    XIdempotencyKey:
      name: X-Idempotency-Key
      in: header
      schema: { type: string, minLength: 8, maxLength: 80 }
      description: Prevent duplicate orchestration on retries

  schemas:
    # ---------- Requests & pricing ----------
    CartItem:
      type: object
      required: [productId, quantity]
      properties:
        productId: { type: string, format: uuid }
        quantity: { type: integer, minimum: 1 }
        # Optional client hint; service will verify with Inventory:
        unitPriceHint: { type: number, format: float, minimum: 0, nullable: true }

    PricingRequest:
      type: object
      required: [items]
      properties:
        items:
          type: array
          minItems: 1
          items: { $ref: '#/components/schemas/CartItem' }
        currency: { type: string, pattern: '^[A-Z]{3}$', default: SGD }
        at: { type: string, format: date-time, nullable: true }
        stackingPolicy:
          type: string
          enum: [none, sequential]
          default: none
          description: >
            none = choose the single max discount per product;
            sequential = apply sequentially: 1 - Π(1 - rate_i)

    LinePrice:
      type: object
      required: [productId, quantity, unitPrice, unitPriceAfter, lineSubtotalBefore, lineDiscountAmount, lineSubtotalAfter]
      properties:
        productId: { type: string, format: uuid }
        name: { type: string, nullable: true }
        quantity: { type: integer, minimum: 1 }
        unitPrice: { type: number, format: float, minimum: 0 }
        unitPriceAfter: { type: number, format: float, minimum: 0 }
        appliedPromotions:
          type: array
          items:
            type: object
            properties:
              promotionId: { type: string, format: uuid }
              name: { type: string }
              discountRate: { type: number, minimum: 0, maximum: 1 }
        effectiveDiscountRate: { type: number, minimum: 0, maximum: 1 }
        lineSubtotalBefore: { type: number, format: float }
        lineDiscountAmount: { type: number, format: float }
        lineSubtotalAfter: { type: number, format: float }

    PricingTotals:
      type: object
      required: [before, discount, after]
      properties:
        before: { type: number, format: float }
        discount: { type: number, format: float }
        after: { type: number, format: float }

    PricingResult:
      type: object
      required: [currency, items, totals]
      properties:
        currency: { type: string, pattern: '^[A-Z]{3}$' }
        items:
          type: array
          items: { $ref: '#/components/schemas/LinePrice' }
        totals: { $ref: '#/components/schemas/PricingTotals' }

    PlaceOrderRequest:
      type: object
      required: [items]
      properties:
        items:
          type: array
          minItems: 1
          items: { $ref: '#/components/schemas/CartItem' }
        currency: { type: string, pattern: '^[A-Z]{3}$', default: SGD }
        at: { type: string, format: date-time, nullable: true }
        stackingPolicy:
          type: string
          enum: [none, sequential]
          default: none
        # Payment preferences (forwarded to Payments service)
        payment:
          type: object
          properties:
            provider: { type: string, enum: [stripe], default: stripe }
            confirm: { type: boolean, default: true }
            paymentMethodId: { type: string, nullable: true }
            receiptEmail: { type: string, format: email, nullable: true }
            metadata:
              type: object
              additionalProperties: { type: string }
        # Reservation behaviour
        reservationTTLSeconds:
          type: integer
          minimum: 60
          maximum: 1800
          default: 300

    # ---------- Composite order ----------
    PaymentSummary:
      type: object
      properties:
        provider: { type: string, enum: [stripe] }
        status: { type: string, enum: [processing, requires_action, succeeded, failed] }
        providerPaymentId: { type: string, nullable: true }
        clientSecret: { type: string, nullable: true }
        error:
          type: object
          nullable: true
          properties:
            code: { type: string }
            message: { type: string }

    OrderStatus:
      type: string
      enum:
        - initiated
        - reserved
        - payment_processing
        - confirmed
        - cancelled
        - failed

    OrderComposite:
      type: object
      required: [id, status, currency, items, totals, createdAt]
      properties:
        id: { type: string, format: uuid }
        status: { $ref: '#/components/schemas/OrderStatus' }
        currency: { type: string, pattern: '^[A-Z]{3}$' }
        items:
          type: array
          items: { $ref: '#/components/schemas/LinePrice' }
        totals: { $ref: '#/components/schemas/PricingTotals' }
        # Cross-service references:
        reservationId: { type: string, format: uuid, nullable: true }
        receiptId: { type: string, format: uuid, nullable: true }
        payment: { $ref: '#/components/schemas/PaymentSummary' }
        # Optional backing order id if you persist in an Orders atomic service
        orderRecordId: { type: string, format: uuid, nullable: true }
        createdAt: { type: string, format: date-time }
        updatedAt: { type: string, format: date-time, nullable: true }

    # ---------- Events your orchestrator might publish ----------
    OrderPlacedEvent:
      type: object
      properties:
        eventType: { const: order.placed }
        orderId: { type: string, format: uuid }
        amount: { type: number, format: float }
        currency: { type: string, pattern: '^[A-Z]{3}$' }
        occurredAt: { type: string, format: date-time }
      required: [eventType, orderId, amount, currency, occurredAt]

    OrderFailedEvent:
      type: object
      properties:
        eventType: { const: order.failed }
        orderId: { type: string, format: uuid }
        reason: { type: string }
        occurredAt: { type: string, format: date-time }
      required: [eventType, orderId, occurredAt]

    OrderCancelledEvent:
      type: object
      properties:
        eventType: { const: order.cancelled }
        orderId: { type: string, format: uuid }
        occurredAt: { type: string, format: date-time }
      required: [eventType, orderId, occurredAt]

    # ---------- Errors ----------
    Problem:
      type: object
      description: RFC 7807 problem+json
      properties:
        type:   { type: string, format: uri }
        title:  { type: string }
        status: { type: integer }
        detail: { type: string }
        instance: { type: string, format: uri }
      required: [title, status]

  responses:
    BadRequest:
      description: Validation or malformed input
      content:
        application/problem+json:
          schema: { $ref: '#/components/schemas/Problem' }
    Unauthorized:
      description: Missing/invalid API key
      content:
        application/problem+json:
          schema: { $ref: '#/components/schemas/Problem' }
    NotFound:
      description: Resource not found
      content:
        application/problem+json:
          schema: { $ref: '#/components/schemas/Problem' }
    Unprocessable:
      description: Semantically invalid request
      content:
        application/problem+json:
          schema: { $ref: '#/components/schemas/Problem' }
    ServerError:
      description: Unexpected error
      content:
        application/problem+json:
          schema: { $ref: '#/components/schemas/Problem' }
